# コンテキストエンジニアリングとユビキタス言語

## 目次
1. [システム設計におけるコンテキストエンジニアリング](#システム設計におけるコンテキストエンジニアリング)
2. [ユビキタス言語とは](#ユビキタス言語とは)
3. [telBotOrderプロジェクトでの実践](#telbotorderプロジェクトでの実践)
4. [ベストプラクティス](#ベストプラクティス)

---

## システム設計におけるコンテキストエンジニアリング

### 定義

コンテキストエンジニアリングとは、**複雑な業務ドメインを理解可能な境界（Bounded Context）で分割し、各コンテキスト内で一貫した言語とモデルを維持する技術**です。

### 境界付けられたコンテキスト（Bounded Context）

同じ用語でも、コンテキストによって意味が異なる概念を明確に分離する設計手法。

#### 例：「注文」という概念の多義性

```
┌─────────────────────────────────────────────────┐
│ 注文コンテキスト                                  │
│ Order: { items, totalAmount, customerId }      │
│ 意味: 顧客が何を注文したか                        │
│ 関心事: 注文内容、金額、顧客情報                   │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ 調理コンテキスト                                  │
│ Order: { tableNumber, items, priority }        │
│ 意味: 何を作るべきか                             │
│ 関心事: テーブル番号、料理内容、優先度              │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ 会計コンテキスト                                  │
│ Order: { sessionId, totalAmount, paymentStatus }│
│ 意味: いくら請求するか                           │
│ 関心事: 合計金額、支払い状態                      │
└─────────────────────────────────────────────────┘
```

---

## telBotOrderプロジェクトでのコンテキスト分離

### 1. 顧客コンテキスト (Customer Context)

**責任**: 注文体験の提供

#### エンティティ

**Session (来店セッション)**
- 意味: 「誰かが来店している状態」
- 属性: `party_size`, `telegram_chat_id`, `status`
- ライフサイクル: テーブルに着席 → 注文 → 会計 → 退店

**Order (注文)**
- 意味: 「何を注文したか」
- 属性: `telegram_user_id`, `order_number`, `total_amount`
- ビジネスルール: 1つのSessionに複数のOrderが紐づく（追加注文可能）

**StaffCall (店員呼び出し)**
- 意味: 「何か手助けが必要」
- 属性: `reason` (water, payment, question, complaint, other)

#### ユビキタス言語

| 用語 | 意味 |
|------|------|
| セッション | テーブルに座っている状態 |
| 注文 | 1回の注文操作 |
| 追加注文 | 同じセッションでの新しい注文 |
| 店員呼び出し | 顧客からのサポート要請 |

#### コード例

```typescript
// 顧客コンテキストでのSession
class Session {
  id: string;
  partySize: number;           // 来店人数
  status: SessionStatus;       // active, payment_requested, completed
  orders: Order[];             // 注文のリスト
  
  canAddOrder(): boolean {
    return this.status === SessionStatus.ACTIVE;
  }
  
  requestPayment(): void {
    if (this.orders.length === 0) {
      throw new Error('注文がないため会計できません');
    }
    this.status = SessionStatus.PAYMENT_REQUESTED;
  }
}

enum SessionStatus {
  ACTIVE            = 'active',
  PAYMENT_REQUESTED = 'payment_requested',
  COMPLETED         = 'completed',
  CANCELLED         = 'cancelled'
}
```

---

### 2. 調理コンテキスト (Kitchen Context)

**責任**: 調理工程の管理

#### エンティティ

**OrderItem (注文明細)**
- 意味: 「何を作るべきか」
- 属性: `status` (pending → cooking → ready → served)
- 関心事: テーブル番号、商品名、数量、調理状態

**MenuItem**
- 意味: 「作れる料理」
- 属性: `is_available` (売り切れフラグ)
- 関心事: 材料の有無、提供可能性

#### ユビキタス言語

| 用語 | 意味 |
|------|------|
| オーダー | 作るべき商品の単位 |
| ペンディング | 未調理 |
| クッキング | 調理中 |
| レディ | 提供待ち |
| サーブド | 提供済み |

#### コード例

```typescript
// 調理コンテキストでのOrderItem
class KitchenOrderItem {
  tableNumber: string;         // テーブル番号（顧客識別）
  menuItemName: string;        // 料理名
  quantity: number;            // 数量
  status: KitchenStatus;       // 調理状態
  note: string;                // 調理メモ（アレルギー対応など）
  
  startCooking(): void {
    if (this.status !== KitchenStatus.PENDING) {
      throw new Error('既に調理開始済みです');
    }
    this.status = KitchenStatus.COOKING;
  }
  
  markAsReady(): void {
    if (this.status !== KitchenStatus.COOKING) {
      throw new Error('調理中でないため完了できません');
    }
    this.status = KitchenStatus.READY;
  }
}

enum KitchenStatus {
  PENDING  = 'pending',   // 未調理
  COOKING  = 'cooking',   // 調理中
  READY    = 'ready',     // 提供待ち
  SERVED   = 'served'     // 提供済み
}
```

---

### 3. 会計コンテキスト (Payment Context)

**責任**: 金額計算と決済

#### エンティティ

**Payment (会計)**
- 意味: 「いくら請求するか」
- 属性: `total_amount`, `payment_method`, `status`
- 制約: Session 1対1 (テーブル単位の一括会計)

**Order (注文の集計ビュー)**
- 意味: 「合計金額の内訳」
- 属性: `total_amount` (スナップショット)

#### ユビキタス言語

| 用語 | 意味 |
|------|------|
| 会計 | テーブル全体の支払い |
| 合計金額 | 全注文の総額 |
| 支払い方法 | cash, credit_card, electronic |

#### コード例

```typescript
// 会計コンテキストでのPayment
class Payment {
  sessionId: string;
  totalAmount: Decimal;        // 合計金額
  paymentMethod: PaymentMethod;
  status: PaymentStatus;
  
  calculateTotal(orders: Order[]): Decimal {
    return orders
      .filter(order => order.status !== OrderStatus.CANCELLED)
      .reduce((sum, order) => sum.add(order.totalAmount), new Decimal(0));
  }
  
  complete(method: PaymentMethod): void {
    if (this.status !== PaymentStatus.PENDING) {
      throw new Error('既に会計済みです');
    }
    this.paymentMethod = method;
    this.status = PaymentStatus.PAID;
  }
}

enum PaymentMethod {
  CASH          = 'cash',
  CREDIT_CARD   = 'credit_card',
  ELECTRONIC    = 'electronic'
}

enum PaymentStatus {
  PENDING   = 'pending',
  PAID      = 'paid',
  CANCELLED = 'cancelled'
}
```

---

### 4. メニュー管理コンテキスト (Menu Management Context)

**責任**: 商品情報の管理

#### エンティティ

**MenuItem (メニュー項目)**
- 意味: 「販売可能な商品」
- 属性: `price`, `is_available`, `is_active`, `display_order`

**Category (カテゴリ)**
- 意味: 「商品の分類」

**MenuItemImage (商品画像)**
- 意味: 「商品の見た目」
- 属性: `image_type` (original, thumbnail, large)

#### ユビキタス言語

| 用語 | 意味 |
|------|------|
| メニュー | 提供可能な商品一覧 |
| 売り切れ | is_available = FALSE（一時的） |
| 非表示 | is_active = FALSE（恒久的） |
| カテゴリ | 商品の分類（前菜、メイン、デザート等） |

#### コード例

```typescript
// メニュー管理コンテキストでのMenuItem
class MenuItem {
  id: string;
  name: string;
  price: Decimal;
  isSoldOut: boolean;          // 売り切れ（一時的）
  isActive: boolean;           // 有効（恒久的）
  
  markAsSoldOut(): void {
    this.isSoldOut = true;
    // ビジネスルール: 売り切れでもメニューには表示される（グレーアウト）
  }
  
  deactivate(): void {
    this.isActive = false;
    // ビジネスルール: 非表示の商品はメニューに表示されない
  }
  
  isAvailable(): boolean {
    return this.isActive && !this.isSoldOut;
  }
}
```

---

### コンテキスト間の統合（Context Mapping）

#### 統合パターン

```
1. 【共有カーネル】Session
   ┌─────────────┐
   │   Session   │ ← 複数コンテキストで共有される核
   └─────────────┘
        ↓ ↓ ↓
   顧客 調理 会計

2. 【顧客/サプライヤー関係】
   顧客コンテキスト (上流) → 調理コンテキスト (下流)
   - Order作成 → OrderItemが調理キューに入る
   - 顧客の注文が調理を駆動

3. 【準拠者(Conformist)】
   調理コンテキスト → 顧客コンテキスト
   - OrderItem.statusが更新される
   - 顧客は調理状況を「見るだけ」

4. 【公開ホストサービス】
   メニュー管理コンテキスト → REST API
   - GET /api/menu-items → 顧客アプリに提供
   - 管理画面から更新 → リアルタイム反映
```

#### 実装上の境界（技術的分離）

```
プロジェクト構造:
C:\Users\user\gh\telBotOrder\
├── server\                    # バックエンド（全コンテキストの統合）
│   ├── src\
│   │   ├── menu\             # メニュー管理コンテキスト
│   │   ├── order\            # 顧客 + 調理コンテキスト
│   │   ├── payment\          # 会計コンテキスト
│   │   └── staff\            # スタッフ管理
│   └── prisma\
│       └── schema.prisma     # 統合データモデル
│
├── apps\
│   ├── customer-app\         # 顧客コンテキストのUI
│   ├── admin-web\            # メニュー管理 + 会計コンテキストのUI
│   └── bot\                  # Telegram統合（顧客コンテキストの入口）
```

---

## ユビキタス言語とは

### 定義

**ユビキタス言語（Ubiquitous Language）**: ドメイン駆動設計（DDD）において、開発チーム全員（エンジニア、ビジネス担当者、ドメインエキスパート）が共通して使う言葉・用語体系。

### 語源

- **Ubiquitous** = 「どこにでもある、普遍的な」
- システム設計からコード、会話まで「至る所で」同じ言葉を使う

---

### なぜ必要か？

#### ❌ ユビキタス言語がない場合

```
ビジネス側:
「お客様がテーブルに着いたら、セッションを開始します」

開発者A:
「user_table_entryレコードを作成するんですね」

開発者B:
「visit_recordテーブルに insert ですか？」

データベース:
CREATE TABLE customer_sessions ...
```

**問題点**:
- 同じ概念を4つの異なる言葉で表現
- コミュニケーションコスト増大
- 認識のズレが発生
- コードを見ても業務が理解できない

#### ✅ ユビキタス言語がある場合

```
全員が同じ言葉で話す:
「お客様がテーブルに着いたら、Sessionを開始します」

コード:
class Session {
  start(tableId: string, partySize: number) { ... }
}

データベース:
CREATE TABLE sessions (
  id, table_id, party_size, status, started_at ...
)

会話:
「Session の status が active のままになっているバグがあります」
```

**利点**:
- 全員が同じ言葉で意思疎通
- コードがドキュメントになる
- 業務知識がコードに反映される

---

### ユビキタス言語の具体例

#### 1. Session（セッション）

```
❌ 曖昧な表現:
- 「お客さんの情報」
- 「テーブルの予約」
- 「訪問レコード」

✅ ユビキタス言語:
Session = 顧客がテーブルに着席してから退店するまでの一連の活動

会話例:
「Session が active の間は追加注文できます」
「Session を completed にすると、もう注文できません」

コード:
enum SessionStatus {
  ACTIVE            // 来店中
  PAYMENT_REQUESTED // 会計依頼中
  COMPLETED         // 完了
  CANCELLED         // キャンセル
}
```

#### 2. Order（注文）

```
❌ 曖昧な表現:
- 「カートの中身」
- 「リクエスト」
- 「オーダーデータ」

✅ ユビキタス言語:
Order = 1回の注文操作で送信された商品のまとまり

ビジネスルール:
「1つの Session には複数の Order が存在できる」
「追加注文 = 同じ Session に新しい Order を作成する」

コード:
interface Order {
  sessionId: string;      // どのSessionの注文か
  orderNumber: number;    // Session内での注文番号（1回目、2回目...）
  totalAmount: Decimal;   // この注文の合計金額
  status: OrderStatus;    // pending, cooking, ready, served
}
```

#### 3. OrderItem（注文明細） vs MenuItem（メニュー項目）

```
❌ 混同しやすい:
「メニューと注文って何が違うの？」

✅ ユビキタス言語による明確化:

MenuItem = レストランが提供可能な商品
- 「カルボナーラ」という料理そのもの
- 価格: 1300円
- 状態: 売り切れか、提供可能か

OrderItem = 顧客が実際に注文した商品の記録
- 「カルボナーラ 2つ」という注文内容
- 注文時の価格: 1300円（スナップショット）
- 状態: 未調理、調理中、提供済み

ビジネスルール:
「MenuItemの価格が変わっても、過去のOrderItemの価格は変わらない」
```

#### 4. isSoldOut（売り切れ） vs isActive（有効）

```
❌ 曖昧な表現:
「このメニュー、使えなくしておいて」

✅ ユビキタス言語:

isSoldOut = 一時的に提供できない（今日は材料切れ）
- 明日になったら true → false に戻す可能性あり
- 顧客には「売り切れ」と表示

isActive = 恒久的にメニューから削除（廃番商品）
- メニュー改定で削除された商品
- 顧客には表示されない

会話例:
「カルボナーラが売り切れました」
→ MenuItem.isSoldOut = true に更新

「季節限定メニューを終了します」
→ MenuItem.isActive = false に更新
```

#### 5. StaffCall（店員呼び出し）

```
✅ ユビキタス言語:

StaffCall.reason（呼び出し理由）のEnum値:
- WATER: 「お水が欲しい」
- PAYMENT: 「会計したい」
- QUESTION: 「質問がある」
- COMPLAINT: 「苦情・問題」
- OTHER: 「その他」

これらの言葉は:
- データベースに保存
- コードで使用
- UI画面に表示
- スタッフとの会話で使用

全て同じ用語で統一されている
```

---

### ユビキタス言語の構築プロセス

#### 1. ドメインエキスパートとの対話

```
開発者: 「お客さんがメニューを選ぶ画面、どう呼びますか？」
店長: 「注文画面ですね」
開発者: 「注文確定前は？」
店長: 「カートに入れる、ですかね」
開発者: 「でも実店舗にカートはないですよね？」
店長: 「確かに...『選択中の商品』かな」

→ 「cart」ではなく「selectedItems」を使う決定
```

#### 2. 用語集の作成

```markdown
# 用語集（Glossary）

## Session（セッション）
顧客がテーブルに着席してから退店するまでの一連の活動。
複数人が同じテーブルに座っている場合、1つのSessionを共有する。

## Order（注文）
1回の注文操作で送信された商品のまとまり。
1つのSessionで複数のOrderを作成できる（追加注文）。

## OrderItem（注文明細）
Orderに含まれる個別の商品。
MenuItemの情報をスナップショットとして保持する。

## MenuItem（メニュー項目）
レストランが提供可能な商品の定義。
価格、説明、画像などを含む。
```

#### 3. コードへの反映

```typescript
// ❌ ユビキタス言語を使わない
class CustomerTableEntry {
  user_list: Array<any>;
  cart_items: Array<any>;
  is_finished: boolean;
}

// ✅ ユビキタス言語を使う
class Session {
  partySize: number;        // 来店人数
  orders: Order[];          // 注文のリスト
  status: SessionStatus;    // active, payment_requested, completed
  
  canAddOrder(): boolean {
    return this.status === SessionStatus.ACTIVE;
  }
}
```

---

### ユビキタス言語のメリット

#### 1. コミュニケーション効率の向上

```
❌ 翻訳が必要:
店長: 「お客さんがテーブルに座ったら...」
開発者: （心の中）「ああ、user_table_entry を作るのね」

✅ 直接理解:
店長: 「Session を開始したら...」
開発者: 「はい、Session.start() を呼びます」
```

#### 2. バグの早期発見

```
会話:
「会計後に Order を追加できちゃうバグがあります」

すぐに理解できる:
- Session.status が PAYMENT_REQUESTED の時
- 新しい Order を作成できてしまう
- ビジネスルール違反

修正箇所が明確:
if (session.status !== SessionStatus.ACTIVE) {
  throw new Error('会計依頼後は追加注文できません');
}
```

#### 3. 新メンバーのオンボーディング

```
新人開発者がコードを読む:

class Order {
  orderNumber: number;  // → 「注文番号なんだな」
  status: OrderStatus;  // → 「ステータス管理されてるんだ」
  
  cancel() {           // → 「注文キャンセルできるんだ」
    this.status = OrderStatus.CANCELLED;
  }
}

→ コードを読むだけで業務フローが理解できる
```

#### 4. ドキュメントの自己同期

```typescript
// コード自体がドキュメント
enum StaffCallReason {
  WATER,      // お水が欲しい
  PAYMENT,    // 会計したい
  QUESTION,   // 質問がある
  COMPLAINT,  // 苦情・問題
  OTHER       // その他
}

// → 別途ドキュメントを書く必要が減る
```

---

### アンチパターン（やってはいけないこと）

#### 1. 技術用語の押し付け

```
❌ NG:
開発者: 「DTO でデータを転送して、Repository パターンで永続化します」
店長: 「？？？」

✅ OK:
開発者: 「注文データを保存します」
```

#### 2. コンテキストをまたいだ用語の混同

```
❌ NG:
// 顧客コンテキストと調理コンテキストで同じクラス
class Order {
  customerName: string;    // 顧客視点
  cookingPriority: number; // 調理視点
  // → 責任が混ざっている
}

✅ OK:
// 顧客コンテキスト
class CustomerOrder {
  orderNumber: number;
  totalAmount: Decimal;
}

// 調理コンテキスト
class KitchenTicket {
  tableNumber: string;
  items: CookingItem[];
  priority: number;
}
```

#### 3. 略語の乱用

```
❌ NG:
class Sess { ... }  // Sessionの略
class Ord { ... }   // Orderの略
class MI { ... }    // MenuItemの略

✅ OK:
class Session { ... }
class Order { ... }
class MenuItem { ... }
// → 完全な単語を使う
```

---

## telBotOrderプロジェクトでの実践

### データモデルでのユビキタス言語

```prisma
// server/prisma/schema.prisma

// ==================== セッション管理 ====================
model Session {
  id            String        @id @default(cuid())
  tableId       String
  partySize     Int           // 来店人数（ユビキタス言語）
  status        SessionStatus @default(ACTIVE)
  startTime     DateTime      @default(now())
  endTime       DateTime?
  
  table       Table        @relation(fields: [tableId], references: [id])
  orders      Order[]
  staffCalls  StaffCall[]
  
  @@map("sessions")
}

enum SessionStatus {
  ACTIVE            // 来店中
  PAYMENT_REQUESTED // 会計依頼中
  COMPLETED         // 完了
  CANCELLED         // キャンセル
}

// ==================== 注文管理 ====================
model Order {
  id           String      @id @default(cuid())
  sessionId    String
  orderNumber  Int         // Session内での注文番号
  totalAmount  Decimal     @default(0) @db.Decimal(10, 2)
  status       OrderStatus @default(PENDING)
  
  session    Session     @relation(fields: [sessionId], references: [id])
  orderItems OrderItem[]
  
  @@unique([sessionId, orderNumber])
  @@map("orders")
}

enum OrderStatus {
  PENDING   // 注文受付済み
  PREPARING // 調理中
  READY     // 調理完了
  SERVED    // 提供済み
  CANCELLED // キャンセル
}

// ==================== 店員呼び出し ====================
model StaffCall {
  id        String          @id @default(cuid())
  sessionId String
  reason    StaffCallReason // ユビキタス言語: 呼び出し理由
  status    StaffCallStatus @default(PENDING)
  
  @@map("staff_calls")
}

enum StaffCallReason {
  WATER     // お水が欲しい
  PAYMENT   // 会計したい
  QUESTION  // 質問がある
  COMPLAINT // 苦情・問題
  OTHER     // その他
}
```

### APIエンドポイントでのユビキタス言語

```typescript
// REST API設計

// 顧客コンテキスト
POST   /api/sessions              // セッション開始
POST   /api/sessions/:id/orders   // 注文作成（追加注文）
POST   /api/sessions/:id/staff-calls // 店員呼び出し
POST   /api/sessions/:id/payment  // 会計依頼

// 調理コンテキスト
GET    /api/kitchen/orders        // 調理キュー取得
PATCH  /api/kitchen/orders/:id/start-cooking  // 調理開始
PATCH  /api/kitchen/orders/:id/mark-ready     // 調理完了

// メニュー管理コンテキスト
GET    /api/menu-items            // メニュー一覧
PATCH  /api/menu-items/:id/sold-out  // 売り切れ設定
PATCH  /api/menu-items/:id/deactivate // 非表示設定
```

### UI/UXでのユビキタス言語

```typescript
// customer-app/src/components/OrderButton.tsx

function OrderButton({ session }: { session: Session }) {
  const canOrder = session.status === 'ACTIVE';
  
  return (
    <button disabled={!canOrder}>
      {canOrder ? '注文する' : '会計依頼中のため注文できません'}
    </button>
  );
}

// admin-web/src/components/KitchenDashboard.tsx

function KitchenOrderCard({ orderItem }: { orderItem: OrderItem }) {
  const statusText = {
    pending: '未調理',
    cooking: '調理中',
    ready: '提供待ち',
    served: '提供済み'
  };
  
  return (
    <div>
      <h3>{orderItem.menuItemName}</h3>
      <Badge>{statusText[orderItem.status]}</Badge>
    </div>
  );
}
```

---

## ベストプラクティス

### 1. コンテキスト境界の設定

#### ✅ 良い境界の例

```
境界の基準:
- 異なる関心事を持つ
- 異なる変更頻度を持つ
- 異なるチームが担当する
- 異なる言葉の意味を持つ

例：
顧客コンテキスト ≠ 調理コンテキスト
- 顧客: 「注文の合計金額」に関心
- 調理: 「調理の優先順位」に関心
```

#### ❌ 悪い境界の例

```
過度な分割:
- 1つのエンティティに1つのコンテキスト
- マイクロサービスの過剰な分割
- コミュニケーションコストが増大

不十分な分割:
- 全てを1つのコンテキストに詰め込む
- 責任が不明確
- 変更の影響範囲が広すぎる
```

### 2. ユビキタス言語の維持

#### 用語集の作成と更新

```markdown
# 用語集 (Glossary)

最終更新: 2025-11-27

## Session（セッション）
**定義**: 顧客がテーブルに着席してから退店するまでの一連の活動

**ライフサイクル**:
1. QRコードスキャン → Session作成（ACTIVE）
2. 注文 → Order追加
3. 会計依頼 → status = PAYMENT_REQUESTED
4. 支払完了 → status = COMPLETED

**ビジネスルール**:
- 1テーブルに1つのアクティブSessionのみ
- ACTIVEの時のみ追加注文可能
- PAYMENT_REQUESTED でも会計キャンセル後は追加注文可能

**関連エンティティ**: Table, Order, StaffCall, Payment
```

#### 定期的な用語レビュー

```
スプリントレビュー時:
1. 新しく追加された用語の確認
2. 曖昧な用語の明確化
3. 使われなくなった用語の削除
4. コードと用語集の同期確認
```

### 3. コンテキスト間の統合パターン

#### 共有カーネル（Shared Kernel）

```typescript
// 複数のコンテキストで共有されるコアモデル
// 変更時は全コンテキストに影響するため慎重に

interface Session {
  id: string;
  tableId: string;
  status: SessionStatus;
}

// 顧客コンテキストで使用
// 調理コンテキストで使用
// 会計コンテキストで使用
```

#### 腐敗防止層（Anti-Corruption Layer）

```typescript
// OrderItemにMenuItemの情報をスナップショット
class OrderItem {
  menuItemId: string;
  menuItemName: string;     // スナップショット
  unitPrice: Decimal;       // スナップショット
  
  // MenuItemが変更されても影響を受けない
}

// メニュー管理コンテキストの変更から保護
```

### 4. コミュニケーション戦略

#### チーム間の言葉の統一

```
悪い例:
- 開発チーム: 「Order」
- ビジネスチーム: 「注文」
- サポートチーム: 「オーダー」

良い例:
- 全チーム: 「Order（注文）」
- ドキュメント: 英語と日本語を併記
- コード: 英語（Order）
- UI: 日本語（注文）
```

#### ドメインモデルの可視化

```
定期的に図を更新:
- コンテキストマップ
- エンティティ関連図
- 状態遷移図
- ユースケース図

→ チーム全員が同じ理解を持つ
```

---

## まとめ

### コンテキストエンジニアリング

| 項目 | 説明 |
|------|------|
| **定義** | 複雑なドメインを境界で分割し、各コンテキスト内で一貫したモデルを維持する技術 |
| **目的** | 責任の明確化、独立した進化、保守性の向上 |
| **キーコンセプト** | Bounded Context（境界付けられたコンテキスト） |
| **実装** | ディレクトリ構造、モジュール分割、マイクロサービス |

### ユビキタス言語

| 項目 | 説明 |
|------|------|
| **定義** | チーム全員が使う共通の言葉・用語体系 |
| **目的** | コミュニケーションの齟齬をなくす、コードが業務を表現 |
| **範囲** | 会話、コード、DB、ドキュメント全て |
| **作成者** | ビジネス側と開発側が協力して定義 |
| **維持** | 用語集の作成、定期的なレビュー、コードへの反映 |

### telBotOrderプロジェクトでの適用

1. **4つのコンテキスト**: 顧客、調理、会計、メニュー管理
2. **明確なユビキタス言語**: Session, Order, OrderItem, MenuItem, StaffCall
3. **コードとの一貫性**: Prismaスキーマ、TypeScript型定義、API設計
4. **ビジネスルールの表現**: enum値、メソッド名、バリデーション

---

**参考文献**:
- Eric Evans, "Domain-Driven Design: Tackling Complexity in the Heart of Software"
- Vaughn Vernon, "Implementing Domain-Driven Design"
- Martin Fowler, "BoundedContext" (martinfowler.com)

**作成日**: 2025-11-27
**プロジェクト**: telBotOrder
**バージョン**: 1.0
