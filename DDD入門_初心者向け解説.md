# ドメイン駆動設計（DDD）を分かりやすく解説

## 目次
1. [DDDって何？一言で言うと](#dddって何一言で言うと)
2. [なぜDDDが必要なの？](#なぜdddが必要なの)
3. [DDDの基本的な考え方](#dddの基本的な考え方)
4. [具体例で理解するDDD](#具体例で理解するddd)
5. [実際にどう使うの？](#実際にどう使うの)

---

## DDDって何？一言で言うと

**「ビジネスの人と開発者が、同じ言葉でシステムを作る方法」**

これだけです。難しく考えすぎないでください。

---

## なぜDDDが必要なの？

### よくある失敗例

```
📋 ビジネス担当者の説明:
「お客様がテーブルに座ったら、QRコードをスキャンして
 注文画面が開きます。何度でも追加注文できます。
 会計したくなったら、ボタンを押すだけです」

💻 開発者が作ったもの:
CREATE TABLE customer_visit (
  id INT,
  user_data TEXT,
  order_json TEXT
);

😱 問題点:
- 「テーブルに座る」→「customer_visit」って何？
- 「追加注文」の仕組みが不明
- 「会計ボタン」の状態管理がない
- 3ヶ月後、誰も分からない...
```

### DDDを使った場合

```
👥 ビジネス担当者と開発者の会話:

ビジネス: 「お客様がテーブルに座ったら...」
開発者  : 「それ、Sessionって呼びましょう」
ビジネス: 「いいですね！で、注文は何度でもできます」
開発者  : 「Session に複数の Order が紐づくんですね」

💻 開発者が作ったもの:
class Session {
  placeOrder() { ... }      // 注文する
  requestPayment() { ... }  // 会計する
}

✅ 結果:
- コードを見れば業務が分かる
- 変更が簡単
- 新しい人もすぐ理解できる
```

---

## DDDの基本的な考え方

### 1. 同じ言葉を使う（ユビキタス言語）

```
❌ 悪い例:
ビジネス: 「来店」
開発者  : 「visit_record」

別々の言葉 → 認識のズレ → バグ

✅ 良い例:
ビジネス: 「Session（来店セッション）」
開発者  : 「Session」

class Session { ... }  ← コードでも Session

同じ言葉 → 誤解なし → 正確
```

### 2. ビジネスのルールをコードに書く

```
ビジネスルール:
「会計依頼中は追加注文できない」

❌ 悪い書き方:
// コントローラー（画面の処理）に書く
if (session.status == "PAYMENT_REQUESTED") {
  alert("注文できません");
}

→ いろんな場所に同じコードが散らばる
→ ルール変更時に修正漏れ

✅ 良い書き方:
// Session自身に書く
class Session {
  canAddOrder(): boolean {
    return this.status !== 'PAYMENT_REQUESTED';
  }
}

→ ルールが1箇所に集約
→ 変更が簡単
→ テストしやすい
```

### 3. 意味のあるまとまりで分ける（境界付けられたコンテキスト）

```
レストランシステム全体を小さく分ける:

┌─────────────┐
│ 注文する    │ ← 顧客の視点
│ (Session)   │
└─────────────┘

┌─────────────┐
│ 料理を作る  │ ← キッチンの視点
│ (Kitchen)   │
└─────────────┘

┌─────────────┐
│ 会計する    │ ← レジの視点
│ (Payment)   │
└─────────────┘

それぞれ独立して考える → シンプル
```

---

## 具体例で理解するDDD

### レストランの注文システムで説明

#### ステップ1: ビジネスの人と話す

```
👤 店長さんへのインタビュー:

Q: お客様はどうやって注文しますか？
A: テーブルのQRコードをスマホで読み取ります

Q: 追加注文はできますか？
A: はい、何度でもできます

Q: でも会計ボタンを押した後は？
A: その後は追加注文できません

Q: もし追加したくなったら？
A: 会計をキャンセルすれば、また注文できます
```

#### ステップ2: 重要な言葉を見つける

```
会話から見つけた言葉:

📝 Session（セッション）
  = お客様がテーブルに座ってから帰るまで

📝 Order（注文）
  = 1回の注文操作

📝 Menu（メニュー）
  = 注文できる料理

📝 Payment（会計）
  = お金を払うこと

→ これらを「ユビキタス言語」として使う
```

#### ステップ3: ルールを整理する

```
ビジネスルール:

1️⃣ Session は ACTIVE（来店中）の時だけ注文できる
2️⃣ 会計依頼したら PAYMENT_REQUESTED になる
3️⃣ PAYMENT_REQUESTED の時は注文できない
4️⃣ 会計キャンセルしたら ACTIVE に戻る
```

#### ステップ4: コードにする

```typescript
// 難しそうに見えるけど、実は簡単！

class Session {
  private status: string;  // 状態（ACTIVE or PAYMENT_REQUESTED）
  
  // 注文できるか？
  canOrder(): boolean {
    return this.status === 'ACTIVE';
  }
  
  // 会計を依頼する
  requestPayment(): void {
    if (!this.canOrder()) {
      throw new Error('既に会計依頼済みです');
    }
    this.status = 'PAYMENT_REQUESTED';
  }
  
  // 会計をキャンセル
  cancelPayment(): void {
    this.status = 'ACTIVE';
  }
}
```

**見て！ビジネスのルールがそのままコードになってる！**

---

## 実際にどう使うの？

### 初心者向け：まずはこれだけ

#### 1. 同じ言葉を使う

```
❌ やめること:
- 「データ」「レコード」「情報」みたいな曖昧な言葉
- 開発者だけが分かる専門用語

✅ すること:
- ビジネスの人と相談して言葉を決める
- その言葉をコード、会話、ドキュメント全部で使う

例:
「Session」って決めたら、
- コード: class Session
- 会話: 「Sessionのバグです」
- DB: sessions テーブル
全部 Session で統一！
```

#### 2. ビジネスルールはクラスに書く

```typescript
// ❌ 悪い例: 画面の処理に書く
function onOrderButtonClick() {
  if (session.status === 'PAYMENT_REQUESTED') {
    alert('注文できません');
    return;
  }
  // 注文処理...
}

// ✅ 良い例: Session クラスに書く
class Session {
  canOrder(): boolean {
    return this.status === 'ACTIVE';
  }
}

// 画面の処理
function onOrderButtonClick() {
  if (!session.canOrder()) {
    alert('注文できません');
    return;
  }
  // 注文処理...
}
```

**なぜ良い？**
- ルールが1箇所に集まる
- テストしやすい
- 変更が簡単

#### 3. 小さく分けて考える

```
大きすぎる考え方:
「レストランシステム全体」
→ 複雑で分からない

小さく分ける:
┌──────────┐
│ 注文部分 │ ← まずこれだけ考える
└──────────┘

できたら次:
┌──────────┐
│ 会計部分 │
└──────────┘

→ シンプルで分かりやすい！
```

---

## DDDの用語を超シンプルに

### よく出てくる難しそうな言葉

#### エンティティ（Entity）

```
一言で: 「IDを持つもの」

例:
注文番号123の注文 と 注文番号456の注文
→ 別物（IDが違う）

コード:
class Order {
  id: string;  // ← これがあるからエンティティ
}
```

#### 値オブジェクト（Value Object）

```
一言で: 「値そのもの」

例:
1000円 と 1000円
→ 同じ（値が同じなら同一）

コード:
class Money {
  amount: number;
  currency: string;
  
  // IDは無い
}
```

**簡単な見分け方:**
- 「これとこれは別物？」→ YES → エンティティ
- 「値が同じなら同じ？」→ YES → 値オブジェクト

#### リポジトリ（Repository）

```
一言で: 「データの出し入れをする箱」

class OrderRepository {
  save(order) { ... }      // 保存
  findById(id) { ... }     // 取得
}

→ データベースの複雑な部分を隠す
```

#### 集約（Aggregate）

```
一言で: 「関連するものをまとめたもの」

Session（まとめ役）
├─ Order 1
├─ Order 2
└─ Order 3

→ Sessionを通してしかOrderにアクセスできない
→ ルールを守りやすい
```

---

## よくある質問

### Q1: 全部DDDでやらないといけない？

**A: いいえ！**

```
✅ DDDが役立つ場合:
- 複雑なビジネスルールがある
- 長く使うシステム
- ルールがよく変わる

❌ DDDが不要な場合:
- 単純なCRUD（保存・読込・更新・削除だけ）
- すぐ捨てるプロトタイプ
- ルールがほとんどない
```

### Q2: 小さいプロジェクトでも使える？

**A: 使えます！**

```
最低限これだけ:
1. ビジネスの言葉をそのまま使う
2. ルールをクラスに書く

これだけでも効果あり！
```

### Q3: いきなり完璧にできない...

**A: それが普通です！**

```
DDDは「旅」です:

ステップ1: ビジネスの人と話す
  ↓
ステップ2: 少しずつコードにする
  ↓
ステップ3: 理解が深まる
  ↓
ステップ4: コードを改善
  ↓
ステップ1に戻る（繰り返し）

完璧を目指さない！
少しずつ良くする！
```

---

## まとめ：DDDの本質

### 難しく考えないで！

```
DDDとは:

❌ 複雑な設計パターン
❌ 難しい専門用語
❌ 厳格なルール

✅ ビジネスとコードを近づける
✅ 同じ言葉で話す
✅ シンプルに保つ
```

### 今日から始められること

```
1. ビジネスの人と話す
   → 重要な言葉を見つける

2. その言葉でコードを書く
   → class Session, class Order

3. ルールをクラスに書く
   → canOrder(), requestPayment()

たったこれだけ！
```

### DDDの目標

```
┌─────────────────────────────┐
│ 3ヶ月後に読んでも分かる     │
│ 新しい人もすぐ理解できる     │
│ 変更が怖くない              │
└─────────────────────────────┘

これを目指す！
```

---

## 実践例：超シンプル版

### レストラン注文システムの最小構成

```typescript
// 1. 言葉を決める
class Session {
  status: 'ACTIVE' | 'PAYMENT_REQUESTED';
}

class Order {
  items: MenuItem[];
}

class MenuItem {
  name: string;
  price: number;
}

// 2. ルールを書く
class Session {
  canOrder(): boolean {
    return this.status === 'ACTIVE';
  }
  
  requestPayment() {
    this.status = 'PAYMENT_REQUESTED';
  }
}

// 3. 使う
const session = new Session();

if (session.canOrder()) {
  const order = new Order();
  // 注文処理
}

session.requestPayment();
```

**これだけでも立派なDDD！**

---

## 最後に

### DDDは難しくない

```
❌ 誤解:
「DDDは大規模システムだけ」
「全部の概念を理解しないと使えない」
「完璧にやらないと意味ない」

✅ 真実:
「小さく始められる」
「必要な部分だけ使える」
「少しずつ改善していける」
```

### 覚えておいてほしいこと

```
1. ビジネスの言葉をそのまま使う
   → ユビキタス言語

2. ルールはクラスに書く
   → ドメインモデル

3. 小さく分けて考える
   → 境界付けられたコンテキスト

この3つだけでOK！
```

### 学習の順序

```
Level 1: ユビキタス言語を使う
  ↓
Level 2: クラスにルールを書く
  ↓
Level 3: 小さく分ける
  ↓
Level 4: エンティティ・値オブジェクトを理解
  ↓
Level 5: 集約・リポジトリを使う

焦らず、一つずつ！
```

---

**DDDは「ビジネスとコードを近づける」ただそれだけです。**

難しく考えず、今日から始めてみましょう！

---

**作成日**: 2025-11-27  
**プロジェクト**: telBotOrder  
**対象**: DDD初心者  
**バージョン**: 1.0 (わかりやすい版)
